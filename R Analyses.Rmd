---
title: "Analises"
author: "orlando"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(BasketballAnalyzeR) 
library(gridExtra)
library(tidymodels)
library(dplyr)
library(purrr)
library(ggplot2)
library(tidyverse)
library(corrplot)

```

## R Markdown

```{r reading csv}

data <- read_csv("data/finalDF.csv")  
data$Unnamed <- NULL
data$date <- as.Date(data$date)

# Trim spaces and replace with underscores in 'Name' column
data$Name <- gsub(" ", "_", trimws(data$Name))

#Removing rows where the MP =0 or MP = NA
data <- subset(data, !is.na(MP) & MP != 0)


data
```
Percebi que tenho um problema no DF original devido ao scrapping the identificado padrões idiomáticos diferentes, por exemplo temos como unique name 'nikola_joki?' e nikola_jokić que deveriam ser representados como um jogador e não como 2.


```{r identifying similar players names}
# Identify unique players in the main_df
unique_players <- unique(data$Name)

# Loop through each unique player
for (player in unique_players) {
  # Check if there are any similar player names
  similar_names <- grep(player, unique_players, value = TRUE)
  
  # If there are similar names, correct them
  if (length(similar_names) > 1) {
    # Print the similar names for reference
    print(similar_names)
    
  }
}


```
Agora que já sabemos quais são os jogadores que estão dando problema no nome, podemos criar uma regra para corrigir eles de uma vez.
```{r fixing players names}

fix_player_names <- function(df) {
  name_mapping <- c(
    "mirza_teletović" = "mirza_teletovic",
    "mirza_teletovi?" = "mirza_teletovic",
    "boban_marjanović" = "boban_marjanovic",
    "boban_marjanovi?" = "boban_marjanovic",
    "bojan_bogdanović" = "bojan_bogdanovic",
    "bojan_bogdanovi?" = "bojan_bogdanovic",
    "goran_dragić" = "goran_dragic",
    "goran_dragi?" = "goran_dragic",
    "jusuf_nurkić" = "jusuf_nurkic",
    "jusuf_nurki?" = "jusuf_nurkic",
    "nikola_jokić" = "nikola_jokic",
    "nikola_joki?" = "nikola_jokic",
    "dario_šarić" = "dario_saric",
    "dario_šari?" = "dario_saric",
    "miloš_teodosi?" = "milos_teodosic",
    "miloš_teodosić" = "milos_teodosic",
    "ante_žiži?" = "ante_zizic",
    "ante_žižić" = "ante_zizic",
    "bogdan_bogdanovi?" = "bogdan_bogdanovic",
    "bogdan_bogdanović" = "bogdan_bogdanovic",
    "nikola_mirotić" = "nikola_mirotic",
    "nikola_miroti?" = "nikola_mirotic"
  )
  
  df$Name <- ifelse(df$Name %in% names(name_mapping), name_mapping[df$Name], df$Name)
  
  return(df)
}

# Call the fix_player_names() function to fix the names in the "data" data frame
fixed_data <- fix_player_names(data)



```
Overview of the data
```{r overview}
# Display the first few rows
head(fixed_data)

# Check the structure of the data
str(fixed_data)

# Summary of the DataFrame
summary_df <- summary(fixed_data)
print(summary_df)
```
Data Cleaning:
Notei que as colunas númericas estão ficando com NA ao invés de 0 no df, abaixo vou preenche-las com 0 e investigar o caso onde AST% = -1000. Depois de investigar, eu acredito que esses valores negativos sejam algum tipo de bug na tabela original, portanto a % será transformada em 0
```{r}

# Fill NA values with 0 in the entire DataFrame
df_filled <- replace(fixed_data, is.na(fixed_data), 0)


# Replace negative values with 0 in the filtered DataFrame
df_filled[df_filled$AST. < 0, "AST."] <- 0

# Remove duplicate rows
df_filled <- distinct(df_filled)


summary2_df <- summary(df_filled)
print(summary2_df)


```

Univariate Analysis
```{r UA}
# Histogram of MP variable
ggplot(df_filled, aes(x = MP)) +
  geom_histogram(binwidth = 5) +
  xlab("MP") +
  ylab("Frequency") +
  ggtitle("Distribution of Minutes Played")

# Histogram of PTS variable
ggplot(df_filled, aes(x = PTS)) +
  geom_histogram(binwidth = 5) +
  xlab("Points") +
  ylab("Frequency") +
  ggtitle("Distribution of Points")

# Bar chart of a categorical variable
ggplot(df_filled, aes(x = team)) +
  geom_bar() +
  xlab("Team") +
  ylab("Count") +
  ggtitle("Number of Games Played by Team")
```
Bivariate Analysis
```{r BA}

# Scatter plot of MP x PTS
ggplot(df_filled, aes(x = MP, y = PTS)) +
  geom_point() +
  xlab("MP") +
  ylab("Points") +
  ggtitle("MP vs. Points")

# Correlation matrix of most important variables
correlation_matrix <- cor(df_filled[c("MP","PTS", "AST", "TRB","STL","BLK","TOV","PF","FG","FGA","FG.","X3P","X3PA","X3P.","FT","FTA","FT.")])
corrplot(correlation_matrix, method = "circle")

# Correlation matrix with the advanced stats column
correlation_matrix <- cor(df_filled[c("PTS","AST", "TRB", "TS.","eFG.","X3PAr","FTr","ORB.","DRB.","TRB.","AST.","STL.","BLK.", "TOV.","USG.","ORtg","DRtg","BPM")])
corrplot(correlation_matrix, method = "circle")

numerical_df <- df_filled %>% 
  mutate(team = as.numeric(as.factor(team)),
         opp = as.numeric(as.factor(opp)))

# Correlation matrix with teams and seasonal data
correlation_matrix <- cor(numerical_df[c("PTS","AST", "TRB", "opp","team","season")])
corrplot(correlation_matrix, method = "circle")

#correlation among everything


correlation_matrix <- cor(numerical_df[c("MP","PTS", "AST", "TRB","STL","BLK","TOV","PF","FG","FGA","FG.","X3P","X3PA","X3P.","FT","FTA","FT.", "TS.","eFG.","X3PAr","FTr","ORB.","DRB.","TRB.","AST.","STL.","BLK.", "TOV.","USG.","ORtg","DRtg","BPM","opp","team","season")])
corrplot(correlation_matrix, method = "circle")




```
Multivariate Analysis


```{r}
# Box plot of points by team
ggplot(df_filled, aes(x = team, y = PTS)) +
  geom_boxplot() +
  xlab("Team") +
  ylab("Points") +
  ggtitle("Points by Team") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Line plot of points over time
df_season <- df_filled %>% group_by(season) %>% summarize(avg_points = mean(PTS))
ggplot(df_season, aes(x = season, y = avg_points)) +
  geom_line() +
  xlab("Season") +
  ylab("Average Points") +
  ggtitle("Average Points per Season") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```
Usarei a função nest() para agrupar o df por jogador
```{r nest}

# Assuming your dataframe is named df_filled
nested_data <- df_filled %>% 
    group_by(Name) %>% 
  nest(.key="data")



# Print the nested data
nested_data

```
Testando como está o nested para os jogadores
```{r testing player}
# Filter the nested data for "joel_embiid"
player_data <- nested_data[nested_data$Name == "joel_embiid", ]$data

# Print the nested data for "joel_embiid"
print(player_data)

```
Criando Feature Engineering
```{r feature engineering}

# Function to calculate rest days
calculate_rest_days <- function(df) {
  df$rest_days <- c(0, diff(df$date))
  return(df)
}

# Apply the calculate_rest_days function to nested_data
nested_data <- nested_data %>%
  mutate(data = purrr::map(data, ~ calculate_rest_days(.)))

#Creating the columns next_opp and next_PTS 
nested_data <- nested_data %>%
  mutate(data = map(data, ~ {
    df <- .x
    df$next_opp <- c(df$opp[-1], NA)
    df$next_PTS <- c(df$PTS[-1], NA)
    df
  }))


# View the updated nested_data with the rest_days column within each nested dataset
nested_data
```
Conferindo se as mudanças deram certo
```{r}
player_name <- "joel_embiid"

# Filter the nested data for "joel_embiid"
player_data <- nested_data %>% 
  filter(Name == player_name) %>%
  pull(data) %>%
  pluck(1)

# Print the nested data for "joel_embiid"
print(player_data[, c("date", "rest_days","PTS","next_PTS","opp","next_opp")])
```




Alternativa

Criando uma lista de dataframes onde cada df representará um jogador, criando uma tabela com o index de cada jogador na lista
```{r creating players df}

#df_list <- split(fixed_data, fixed_data$Name)


```
Testing the division with a few players

```{r players df }
#df_list$joel_embiid
#df_list$nikola_jokic


```
Agora vamos criar algumas featured_engineering columns como por exemplo dia de descando entre os jogos.
```{r}
# df_list <- lapply(df_list, function(df) {
#   df$restdays <- c(0, diff(df$date))
#   df
# })
# 
# 
# df_list <- map(df_list, function(df) {
#   df <- df %>% arrange(date) %>% mutate(Next_PTS = lead(PTS))
#   return(df)
# })
# 
# df_list <- map(df_list, function(df) {
#   df <- df %>% arrange(date) %>% mutate(Next_opp = lead(opp))
#   return(df)
# })


```


Testing
```{r}
# set.seed(123)  # Set seed for reproducibility
# 
# data_processed <- df_list$joel_embiid
# 
# data_processed$team <- NULL
# 
# 
# data_split <- initial_split(data_processed, prop = 0.8)  # 80% training, 20% testing
# data_train <- training(data_split)
# data_test <- testing(data_split)
# 
# recipe_points <- recipe(PTS ~ ., data = data_train)
# 
# # Define the preprocessing steps and feature engineering transformations
# recipe_points <- recipe_points %>%
#   step_date(date) %>%  # Convert date column to date type
#   step_rm(Name) %>%  # Remove unnecessary columns
#   step_dummy(all_nominal(), -all_outcomes())  # Encode categorical variables
# 
# # Specify the machine learning model (e.g., linear regression)
# model_points <- linear_reg() %>%
#   set_engine("lm")
# 
# # Combine the recipe and model into a workflow
# workflow_points <- workflow() %>%
#   add_recipe(recipe_points) %>%
#   add_model(model_points)
# 
# model_fit <- fit(workflow_points, data = data_train)
# 
# predictions <- predict(model_fit, new_data = data_test) %>%
#   bind_cols(data_test)  # Combine predictions with actual data
# 
# 
# # Evaluate the model's performance using evaluation metrics
# metrics <- predictions %>%
#   metrics(truth = PTS, estimate = .pred)
# 
# metrics


```


llll
```{r}
# 
# X <- data$AST / data$MP
# Y <- data$TOV / data$MP
# Pl <- data$Name
# out <- simplereg(x = X, y = Y, type = "lin")
# xtitle <- "AST per minute"
# ytitle <- "TOV per minute"
# plot(out, xtitle = xtitle, ytitle = ytitle)
# 
# 
# ```
# ```{r}
# data2018 <- subset(data, season == "2018")
# 
# 
# X <- data2018$AST / data2018$MP
# Y <- data2018$TOV / data2018$MP
# Pl <- data2018$Name
# out <- simplereg(x = X, y = Y, type = "lin")
# xtitle <- "AST per minute"
# ytitle <- "TOV per minute"
# 
# plot(out, xlab = xtitle, ylab = ytitle)  # Use xlab and ylab instead of xtitle and ytitle
# plot.new()  # Call plot.new before adding the regression line
# abline(out, col = "blue")  # Add regression line
# 
# # Customize x-axis and y-axis limits
# xlim <- c(0, 10)
# ylim <- c(0, 5)
# axis(1, xlim)
# axis(2, ylim)
# box()
```


```{r}
# 
# data15m2018 <- subset(data2018, MP>15)
# 
# X <- data.frame(data$PTS, data$X3P, data$FG, data$TRB, data$AST) / data$MP
# 
#  scatterplot(X, data.var=1:5,
# lower=list(continuous="smooth_loess"),
# diag=list(continuous="barDiag"))


```

